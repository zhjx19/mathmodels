---
title: "Gini coefficient and Theil index"
vignette: >
  %\VignetteIndexEntry{Gini coefficient and Theil index}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
format:
  html:
    toc: true
    mathjax: true
    self-contained: true
knitr:
  opts_chunk:
    collapse: true
    comment: '#>'
---

在经济学和社会科学领域，衡量收入或财富分配的不平等程度是一个重要的研究课题。为了量化这种不平等，研究人员开发了多种统计指标，其中最常用的两个是**基尼系数**和**泰尔指数**。

加载包：

```{r message=FALSE}
library(tidyverse)
library(mathmodels)
```

## 个体数据与平均数据

**个体数据**，就是每个人占一行，记录其收入；（分组）**平均数据**，是将人按某分组变量（如部门）分组，每组一行，记录该组的平均收入和人数。

比如，这是 5 名员工的个体数据：

```{r}
df = tibble(dep = c(rep("技术部", 3), rep("销售部", 2)),
            emp = LETTERS[1:5], 
            income = c(10, 12, 20, 5, 8))
df
```


按部门分组汇总，计算每个部门的人均收入和人数，就得到平均数据：

```{r}
df |> 
  summarise(income = mean(income), pop = n(), .by = dep)
```

最常见的平均数据，就是人均指标和人口数的数据，也称为人口加权数据。

计算基尼系数或泰尔指数时，需要区分个体数据和平均数据（人口加权数据），二者的计算公式是不同的。

## 基尼系数

**基尼系数**，通过洛伦茨曲线计算，反映实际收入分布与完全平等线之间的面积比例。该指标直观且易于理解，但对中间群体的变化较为敏感，而对极端值的敏感性相对不足。

### 洛伦兹曲线与基尼系数

**洛伦兹曲线**，是一种用来展示社会中收入或财富的分配情况的曲线图。具体来说，它展示的是：

- `x` 轴：表示人口的累计百分比，从最贫穷的人到最富有的人排列。
- `y` 轴：表示收入或财富的累计百分比。

```{r echo=FALSE, fig.cap="洛伦兹曲线与基尼系数", out.width="45%"}
knitr::include_graphics("figs/lorenz-curve.jpeg")
```

基尼系数，通过洛伦兹曲线与绝对平等线之间的面积来衡量不平等性。具体来说：

- 如果洛伦兹曲线与绝对平等线之间的面积越大，表示不平等性越高。
- 基尼系数实际上就是该面积的量化，是介于 $0$ 到 $1$ 之间的数值。

具体解释：

- $\text{基尼系数 } = 0$：意味着绝对平等，所有人的收入或财富是完全一样的。洛伦兹曲线和绝对平等线重合，没有差距。
- $\text{基尼系数 } = 1$：意味着绝对不平等，所有收入或财富都集中在一个人的手里。洛伦兹曲线向下弯到几乎贴近 `x` 轴和 `y` 轴，除了一个点之外，其他人都几乎没有收入或财富。

### 基尼系数计算方法

(1) 针对个体数据（比如个体收入向量）：
$$
Gini = \frac{\sum_{i=1}^n\sum_{i=1}^n|x_i-x_j|}{2n^2\bar{x}} 
$$

`mathmodels` 包提供了 `gini0()` 函数按上述公式计算个体数据的基尼系数，基本语法：

```{r eval=FALSE}
gini0(y)
```

- `y` 为个体收入向量。

(2) 针对平均数据：即面积法，利用数值积分，近似计算绝对平等线与洛伦兹曲线围成的面积。

记平均收入向量 $\mathbf{I} = (I_1, I_2, \ldots, I_n)$ 和人口向量 $\mathbf{P} = (P_1, P_2, \ldots, P_n)$。

- 对 $\mathbf{I} / \mathbf{P}$ 从小到大排序，按排序索引重排 $\mathbf{I}$ 和 $\mathbf{P}$，为了简便仍记为 $\mathbf{I}$ 和 $\mathbf{P}$。

- 计算累积人口比例和累积收入比例： 
$$
x_k = \frac{\sum_{i=1}^k P_i}{\sum_{i=1}^n P_i}, \quad y_k = \frac{\sum_{i=1}^k I_i}{\sum_{i=1}^n I_i}
$$
其中，$k = 0, 1, \cdots, n$ 且 $x_0 = y_0 = 0$。

- 用梯形法数值积分计算洛伦兹曲线下面积：   
$$
A = \sum_{i=1}^n \frac{(x_i - x_{i-1}) \cdot (y_i + y_{i-1})}{2}
$$

- 绝对平等线下面积为 $0.5$，基尼系数为两面积之差与绝对平等线面积的比值： 
$$
G = \frac{0.5 - A}{0.5} = 1 - 2A 
$$

`mathmodels` 包提供了 `gini()` 函数按上述步骤计算平均数据的基尼系数，基本语法：

```{r eval=FALSE}
gini(y, pop)
```

- `y` 和 `pop` 分别为各分组的人均收入和人口数构成的向量。

### 案例：批量计算基尼系数

数据整理自国家统计局网站，包含 2014-2023 年全国 31 个省份八个主要行业："信息业"、"制造业"、"医疗"、"商贸"、"建筑业"、"教育"、"科研"、"金融业"的平均工资和就业人数。

```{r}
dat = readxl::read_excel("data/income-data.xlsx")
dat
```

### 批量计算基尼系数

#### 每个行业每年份内**省份间工资的不平等程度（基尼系数）**

- 就是简单的分组汇总：按 `年份` 和 `行业` 分组，每组计算出一个基尼系数值

```{r}
res = dat |> 
  summarise(Gini = gini(平均工资, 就业人数), .by = c(年份, 行业)) 
res 
```

- 结果是整洁长表，接着做可视化非常容易：

```{r}
res |> 
  ggplot(aes(年份, Gini, color = 行业)) +
  geom_line() +
  geom_point() +
  theme_minimal()
```

- 若想结果更适合人类阅读，再来个长变宽：

```{r}
res |> 
  pivot_wider(names_from = 行业, values_from = Gini)
```

#### 每个省份每年份内**行业间工资的不平等程度（基尼系数）**

```{r}
dat |> 
  summarise(Gini = gini(平均工资, 就业人数), .by = c(年份, 地区)) |> 
  pivot_wider(names_from = 地区, values_from = Gini)
```

### 绘制洛伦兹曲线

以“教育”行业 2023 年的数据为例，

```{r}
edu23 = dat |> 
  filter(行业 == "教育", 年份 == "2023")
edu23
```

**洛伦兹曲线**（也是计算基尼系数），关键的一步是按 `x / pop` 排序，注意不是按平均收入 `x` 排序，然后计算人口数和平均收入的累计百分比，分别作为 `x` 轴和 `y` 轴绘图即可。

```{r}
edu23 |>
  arrange(平均工资 / 就业人数) |>
  mutate(frac_pop = cumsum(就业人数) / sum(就业人数), 
         frac_inc = cumsum(平均工资) / sum(平均工资)) |>
  ggplot(aes(frac_pop, frac_inc)) +
  geom_line() +
  geom_polygon(fill = "grey70") +
  coord_equal() +
  theme_bw() +
  labs(x = "累计人数百分比", y = "累计收入百分比")
```

- 再看一下，该洛伦兹曲线对应的基尼系数值：

```{r}
gini(edu23$平均工资,edu23$就业人数)
```

## 泰尔指数

**泰尔指数**，是一种基于信息理论的不平等度量方法，其核心思想是衡量收入分布偏离“完全平等”状态的信息熵。泰尔指数的一个显著优点是它可以自然地分解为组间和组内不平等，从而便于分析不同层次（如省、市）对总体不平等的贡献。

### 总体泰尔指数

#### (1) 针对个体数据

$$
T=\frac1n\sum\limits_{i=1}^n\frac{Y_i}{\overline{Y}}\ln(\frac{Y_i}{\overline{Y}})=\sum\limits_{i=1}^n\frac{Y_i}{Y}\ln(\frac{Y_i}{\overline{Y}})=\sum\limits_{i=1}^n\frac{Y_i}{Y}\ln(\frac{Y_i/Y}{1/n})
$$
其中，$T$ 为总体泰尔指数，$Y_i$ 表示第 $i$ 个体的收入，$\overline{Y}$ 表示所有个体的平均收入，$Y$ 表示所有个体的总收入。

三个表达式，按哪个计算都可以。

`mathmodels` 包提供了 `theil0()`函数计算个体数据的总体泰尔指数，基本语法：

```{r eval=FALSE}
theil0(y)
```

- `y` 为个体收入向量。

#### (2) 针对平均数据（人口加权数据）

$$
T=\sum\limits_i\frac{Y_i}Y\ln\frac{Y_i/Y}{N_i/N}=\sum\limits_i\frac{N_i}N\frac{\overline{Y}_i}{\overline{Y}}\ln\frac{\overline{Y}_i}{\overline{Y}}
$$
其中，$Y_i, \, N_i$ 分别表示第 $i$ 组的总收入和总人口，$Y, \, N$ 分别表示所有组的总收入和总人口，故 $\frac{Y_i}{Y}$ 表示第 $i$ 组收入占总收入的比重，$\frac{N_i}{N}$ 表示第 $i$ 组人口数占总人口数的比重。

总收入当然等于人口数乘以平均收入，所以，引入 $\overline{Y_i}, \, \overline{Y}$ 改写为第 2 式，以与平均数据相对应。

`mathmodels` 包提供了 `theil()`函数计算个体数据的总体泰尔指数，基本语法：

```{r eval=FALSE}
theil(y, pop)
```

- `y` 和 `pop` 分别为各分组的人均收入和人口数构成的向量。

### 单分组变量的泰尔指数及其分解

**泰尔指数分解**，就是总体泰尔指数关于单个分组变量 `g` 分解为**组内**和**组间**泰尔指数，同样也需要区分：个体数据和平均数据。

总体泰尔指数，当然可以忽略分组，直接按个体数据或平均数据的计算公式计算。因为要做分解，故可采用分解后的组内与组间泰尔指数加和得到总体泰尔指数：
$$
T = T_w + T_b
$$

从逻辑上叙述清楚比摆一堆公式更好理解，泰尔指数分解计算步骤如下：

(1) 数据关于分组变量 `g` 分为多组，分别对第 $i$ 组的数据，计算每组的总体泰尔指数即 $T_{wi}$
（根据个体数据/平均数据选用相应的前文公式即可）；

(2) 组内泰尔指数 $T_w$ 就是每组的总体泰尔指数关于各组收入对总收入占比的加权和：
$$
T_w = \sum\limits_i \frac{Y_i}{Y} T_{wi}
$$

(3) 组间泰尔指数 $T_b$，是对原始数据按分组变量 `g` 分组汇总到各组的平均收入和人口数，再计算总体泰尔指数（此时一定是平均数据）；

(4) 进一步，可以计算第 $i$ 组组内差距的贡献率以及组内、组间差距的贡献率：
$$
R_{wi}=\frac{Y_i}Y*\frac{T_{wi}}T=\frac{N_i}N\frac{\overline{Y}_i}{\overline{Y}}*\frac{T_{wi}}T 
$$
$$
R_w = \frac{T_w}{T}, \quad R_b =  \frac{T_b} T
$$

这些贡献率满足：$R_w = \sum\limits_i R_{wi}, \, R_w + R_b = 1$。

`mathmodels` 包提供了 `theil0_g()` 和 `theil_g()` 函数，分别针对个体数据和平均数据，关于一个分组变量计算泰尔指数及其分解，基本语法：

```{r eval=FALSE}
theil0_g(data, group, y)
theil_g(data, group, y, pop)
```

- `data` 为包含所需变量的数据框；
- `group` 为单个分组变量的名字；
- `y` 和 `pop` 分别为各分组的人均收入和人口数构成的向量。

返回包含两个成分的列表：

- `theil`: 总体、组间、组内、每个分组的泰尔指数；
- `ratio`: 相应的贡献率。


### 两分组变量的泰尔指数及其分解

#### 1. 两交叉分组变量的泰尔指数及其分解

对于两个交叉分组变量，例如 `group1`（如行业）和 `group2`（如区域：东部、中部、西部），是对单分组变量泰尔指数分解的扩展。总体泰尔指数仍分解为基于 `group1` 的组间和组内部分，但组内部分进一步分解为基于 `group2` 的组间和组内贡献，从而提供交叉分组下更细致的不平等分析。

**组内泰尔指数（`Tw`）及其分解**，目的是衡量 `group1` 内部的不平等，并按 `group2` 进一步分解。对每个 `group1` 分组，

- **`group2` 组间泰尔指数**：

在该 `group1` 内按 `group2`（如区域）汇总数据。计算每 `group2` 的平均收入和人口。使用泰尔公式计算：
$$
T_{g2b} = \sum_j \left( \frac{Y_{ij}}{Y_i} \right) \ln \left( \frac{Y_{ij} / N_{ij}}{Y_i / N_i} \right)
$$
其中，$Y_{ij}$ 和 $N_{ij}$ 是 `group1` 内 `group2` 第 $j$ 组的收入和人口。

- **`group2` 组内泰尔指数**

若 `group2` 内有更细的数据（如区域内的省份），计算每 `group2` 单元的泰尔指数，并按人口占比加权：
$$
T_{g2w} = \sum_j \left( \frac{N_{ij}}{N_i} \right) T_{wij}
$$
其中，$T_{wij}$ 是 `group2` 第 `j` 组内的泰尔指数（若仅为平均数据，`T_{g2w}` 为 $0$）。

`mathmodels` 包提供了 `theil_g2_cross()` 函数实现两交叉分组变量的泰尔指数及其分解，基本语法：

```{r eval=FALSE}
theil_g2_cross(data, group1, group2, y, pop)
```

- `data` 为包含所需变量的数据框；
- `group1` 和 `group2` 分别为交叉的第一和第二分组变量的名字；
- `y` 和 `pop` 分别为各分组的人均收入和人口数构成的向量。

返回包含两个成分的列表：

- `theil`: 总体、`group1` 组间、`group1` 组内、`group2` 组间、`group2` 组内、每个 `group1` 分组的组内泰尔指数；
- `ratio`: 相应的贡献率。


#### 2. 两嵌套分组变量的泰尔指数及其分解

对于两嵌套分组变量 `group1` 和 `group2`，其中 `group2` 嵌套在 `group1` 内（比如省嵌套市），总体泰尔指数分解为基于 `group1` 的组间不平等、基于 `group2` 的组间不平等以及 `group2` 内的组内不平等。与两交叉分组变量不同，嵌套结构的泰尔指数分解更侧重于层次结构。

**(1) `group1` 组间泰尔指数（衡量 `group1` 各分组之间的不平等）**

按 `group1` 汇总数据，计算每组的总收入和总人口，计算组级平均收入，使用平均数据的泰尔公式计算。

**(2) `group2` 组间泰尔指数（衡量每个 `group1` 内 `group2` 各分组之间的不平等）**

在每个 `group1` 分组下，计算每个 `group2` 分组的平均收入和总人口，计算分泰尔指数：
$$
T_b^{g2i} = \sum_j \left( \frac{Y_{ij}}{Y_i} \right) \ln \left( \frac{Y_{ij} / N_{ij}}{Y_i / N_i} \right)
$$
其中，$Y_{ij}$ 和 $N_{ij}$ 是 `group1` 内 `group2` 第 $j$ 分组的收入和人口，$Y_i$ 和 $N_i$ 是该 `group1` 的总收入和人口。

若某 `group1` 内仅有一个 `group2`，则 $T_b^{g2i} = 0$。

总体 $T_b^{g2}$ 为各 `group1` 的 $T_b^{g2i}$ 加权和：
$$
T_b^{g2} = \sum_i \left( \frac{Y_i}{Y} \right) T_b^{g2i}
$$
       
**(3) `group2` 组内泰尔指数（衡量每个 `group2` 分组内部的不平等）**

按 `group1` 和 `group2` 分组数据，计算每个分组内个体数据的泰尔指数 $T_w^{ij}$（若为平均数据，$T_w^{ij} = 0$）。

总体 $T_w$ 为各 `group2` $T_w^{ij}$ 的加权和：
$$
T_w = \sum_i \sum_j \left( \frac{Y_{ij}}{Y} \right) T_w^{ij}
$$

`mathmodels` 包提供了 `theil_g2_nest()` 函数实现两交叉分组变量的泰尔指数及其分解，基本语法：

```{r eval=FALSE}
theil_g2_nest(data, group1, group2, y, pop)
```

- `data` 为包含所需变量的数据框；
- `group1` 和 `group2` 分别为嵌套的第一和第二分组变量的名字；
- `y` 和 `pop` 分别为各分组的人均收入和人口数构成的向量。

返回包含两个成分的列表：

- `theil`: 总体、`group1` 组间、`group2` 组间、`group2` 组内、每个 `group1/group2` 分组的组内泰尔指数；
- `ratio`: 相应的贡献率。

**总结区分：**

- 单分组变量仅将总体泰尔指数分解为组间部分 $T_b$ 和组内部分 $T_w$，无进一步细分。
- 两交叉分组变量将组内部分 $T_w$ 分解为 $T_{wb}$（`group2` 组间）和 $T_{ww}$（`group2` 组内），强调 `group2` 在 `group1` 内的交叉作用。
- 两嵌套分组将组间部分 $T_b$ 分为 $T_{b1}$（ `group1` 间）和 $T_{b2}$（ `group2` 间），$T_w$ 仅为 `group2` 内的不平等，反映严格的层次结构。

### 案例：批量计算泰尔指数及其分解

仍使用前文的 2014-2023 年全国 31 个省份八个主要行业的平均工资和就业人数数据，增加一列 `区域`，将省份划分至"东部"、"中部"、"西部"、"东部"。

```{r}
df = dat |> 
  mutate(区域 = case_match(地区,
    c("北京","天津","河北","上海","江苏","浙江","福建","山东","广东","海南") ~ "东部",
    c("山西","安徽","江西","河南","湖北","湖南") ~ "中部",
    c("辽宁","吉林","黑龙江") ~ "东北",
    .default = "西部"), .before = 地区)
df
```

#### 每年关于行业的收入不平等性（泰尔指数及其分解）

`theil_*()` 系列函数的返回值，特意设计为两个成分的列表，且每个成分是长度相同、元素命名相同的向量，非常方便分组汇总并展开批量结果。

每年就是按年份分组汇总，关于行业就是以 `行业` 为分组变量，分别对每组数据计算关于单个分组变量的泰尔指数及其分解。因为每组返回长度为 $2$ 的对象（列表），所以用 `reframe()` 代替 `summarise()`，结果是行数翻倍。

```{r}
res = dat |> 
  reframe(Theil = theil_g(pick(everything()), group = "行业", 
                          y = "平均工资", pop = "就业人数"), 
          .by = 年份) 
res 
```

`Theil` 列是嵌套的向量，再做横向（往宽）展开即可：

```{r}
res |> 
  unnest_wider(Theil)
```

每个年份，第一行是总体、行业间、行业内泰尔指数，各行业的（总体）泰尔指数；第二行是相应的贡献率，各行业贡献率之和等于行业内贡献率，行业间贡献率 $+$ 行业内贡献率 $= 1$。


#### 每年关于区域的收入不平等性（批量泰尔指数及其分解）

同样做法，只需将分组变量换成 `区域`：

```{r}
df |> 
  reframe(Theil = theil_g(pick(everything()), group = "区域", 
                          y = "平均工资", pop = "就业人数"), 
          .by = 年份) |> 
  unnest_wider(Theil)
```

每个年份，第一行是总体、区域间、区域内泰尔指数，各区域的（总体）泰尔指数；第二行是相应的贡献率，各区域贡献率之和等于区域内贡献率，区域间贡献率 $+$ 区域内贡献率 $= 1$。

#### 两交叉分组泰尔指数及其分解

批量计算每年 `行业` 与 `区域` 两交叉分组泰尔指数及其分解：

```{r}
df |> 
  reframe(Theil = theil_g2_cross(pick(everything()), 
                                 group1 = "行业", group2 = "区域", 
                                 y = "平均工资", pop = "就业人数"), 
          .by = 年份) |> 
  unnest_wider(Theil)
```

注意分解关系：

- 泰尔指数：`T = Tb + Tw`，`Tw = Tw_b + Tw_w`

- 贡献率：`R_Tw = R_Tw_b + R_Tw_w = R_T_信息业 + ... + R_T_金融业`


#### 两嵌套分组泰尔指数及其分解

仅用数据中有嵌套关系的 `区域` 和 `地区` 测试：

```{r}
df |> 
  reframe(Theil = theil_g2_nest(pick(everything()), 
                                group1 = "区域", group2 = "地区", 
                                y = "平均工资", pop = "就业人数"), 
          .by = 年份) |> 
  unnest_wider(Theil)
```

注意分解关系：

- 泰尔指数：`T = Tb_g1 + Tb_g2 + Tw`

- 贡献率：`R_Tb_g2 = R_东部 + ... + R_中部`，`R_Tw = R_东部_上海 + ... + R_东北_黑龙江`
